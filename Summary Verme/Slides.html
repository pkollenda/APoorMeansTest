<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Which Model for Poverty Prediction</title>
    <meta charset="utf-8" />
    <meta name="author" content="Philipp Kollenda" />
    <script src="Slides_files/header-attrs-2.8/header-attrs.js"></script>
    <link href="Slides_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="Slides_files/remark-css-0.0.1/metropolis.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Which Model for Poverty Prediction
## (Working Paper by Paolo Verme 2020)
### Philipp Kollenda
### Vrije Universiteit Amsterdam
### 11 June 2021 (last updated: 05 June 2021)

---






## Why Targeting 
.pull-left[
![](Slides_files/figure-html/plot_povertylines-1.png)&lt;!-- --&gt;
]

.pull-right[
- Determine eligibility for a program.
- Which measure? Which cut-off?

&gt; Consumption (Brown et al.; Verme), Rankings (Martin), ...
&gt; Absolute poverty (line) or relative poverty (rate)

- The relevant measure may not be available for the entire sample ðŸ˜¢
]

---

.pull-left[
# How it started 
![](Slides_files/figure-html/plot_povertylines2-1.png)&lt;!-- --&gt;
]

.pull-right[
# How it's going
![](Slides_files/figure-html/poverty_prediction-1.png)&lt;!-- --&gt;

]

- Fixing the poverty line at 14,925 is too low to reach the targeted 20 percent in the testing data.
- Fixing the poverty rate at 16,063 is too high to reach the targeted 20 percent in the testing data.
- Brown et al. look at both and recommend in practice to fix the poverty rate (focus on exclusion error), Verme fixes poverty line and compares model performance when poverty line changes. 

---
## A combined framework (Brown et al. &amp; Verme)

1. **Modelling**:
    $$ 
    \begin{align}
    y_i = \alpha + \beta x_i + \varepsilon_i \\\\
    1(y_i \leq z) = \alpha' + \beta' x_i + \epsilon_i
    \end{align}
    $$
Choice of outcome (consumption or poverty) and model (Verme: OLS/Logit + Random Forest and LASSO): 6 models

2. **Prediction** (out of sample):
    $$ 
    \begin{align}
    \hat{y_i} = \hat{\alpha} + \hat{\beta} x_i \\\\
    \hat{p}_i = P[y_i \leq z | x_i] = \hat{\alpha}' + \hat{\beta}' x_i + \epsilon_i
    \end{align}
    $$
---

&lt;ol start=3&gt; 
&lt;li&gt; **Classification**:
Use the predictions to classify into poor or non-poor
    $$ 
    \begin{align}
    y_i \rightarrow \text{poor if }&amp;\enspace \hat{y_i} \leq z \\\\
    1(y_i \leq z) \rightarrow \text{poor if }&amp;\enspace \hat{p}_i \geq \tau
    \end{align}
    $$
`\(\tau\)` is a pre-specified probability cut-off (unclear what Verme uses, I try `\(\tau  = 0.5\)`).

--

&lt;script&gt;
   function setColor(color){ 
    document.getElementById("TN").style.backgroundColor='white';
    document.getElementById("FP").style.backgroundColor='white';
    document.getElementById("TP").style.backgroundColor='green';
    document.getElementById("FN").style.backgroundColor='red';
};
&lt;/script&gt;

&lt;script&gt;
   function setColor2(color){ 
    document.getElementById("TP").style.backgroundColor='white';
    document.getElementById("FN").style.backgroundColor='white';
    document.getElementById("TN").style.backgroundColor='green';
    document.getElementById("FP").style.backgroundColor='red';
};
&lt;/script&gt;

&lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;td&gt;
      &lt;th&gt; Predicted Non-Poor &lt;th&gt;
      &lt;th&gt; Predicted Poor &lt;th&gt;
    &lt;tr&gt;
    &lt;tr&gt;
      &lt;th&gt; Real Non-Poor &lt;th&gt;
      &lt;td id="TN"&gt;True Negative (TN)&lt;td&gt;
      &lt;td id="FP"&gt;False Positive (FP)&lt;td&gt;
    &lt;tr&gt;
    &lt;tr&gt;
      &lt;th&gt; Real Poor &lt;th&gt;
      &lt;td id="FN"&gt;False Negative (FN)&lt;td&gt;
      &lt;td id="TP"&gt;True Positive (TP)&lt;td&gt;
&lt;/table&gt;

To evaluate different models we need a targeting measure (Verme: "*objective function*").  
Typically we use the mean squared error: `\(\frac{1}{N}\sum_{i=1}^N(y_i - \hat{y}_i)^2\)`. But here we do not care about all errors equally. Instead, formulate targeting measure in terms of coverage of program.

Verme: "coverage rate" (= 1 - Exclusion Error Rate, `\(1-\frac{\sum 1(\hat{y}_i &gt; z | y_i \leq z)}{\sum 1(y_i\leq z)}\)`) &lt;input id="button1" type="button" value="show" onclick="setColor('red')"&gt;  
Verme: "leakage rate" (= Inclusion Error Rate, `\(\frac{\sum 1(y_i &gt; z | \hat{y}\leq z)}{\sum 1(\hat{y}_i \leq z)}\)`)&lt;input id="button2" type="button" value="show"  onclick="setColor2('red')"&gt;

---
# Verme does what
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
